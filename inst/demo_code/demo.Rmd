---
title: "Bayesian Causal Inference for Recurrent Events with Timing Misalignment"
author: "Yuqin"
date: "2025-08-15"
output:
  pdf_document:
    latex_engine: lualatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE, fig.width = 11, fig.height = 8.5, dpi = 150, fig.align = "center")

library(BayCauRETM)
library(dplyr)
library(tidyr)
library(rstan)
library(parallel)
library(rstudioapi)
set.seed(42)
```

This Markdown of the Bayesian framework was proposed by Oganisian et al. (2024) for causal inference with recurrent events subject to timing misalignment. We use a semiparametric Bayesian model to estimate the average causal effect of a time-varying treatment on the recurrent event rate, accounting for terminal events and censoring.

## 1. Setup

We configure Stan and set parallelization options for efficient MCMC workflow. We fix the random seed, enable parallel sampling, and set Hamiltonian Monte Carlo controls. The defaults (warmup = 500, M (posterior draws) = 500, 4 chains) are modest for illustration.

```{r}
use_multicore <- TRUE   # FALSE for single core
if (use_multicore) {
  cores <- max(1, detectCores() - 2)
} else {
  cores <- 1
}
options(mc.cores = cores)
rstan_options(auto_write = TRUE)

warmup <- 500
M      <- 500
iter   <- warmup + M
B      <- 50
s_vec  <- c(3, 6, 9)
```

## 2. Data Preprocessing

This step prepares the longitudinal dataset for analysis, including normalization and handling of missing values.

The package expects a long panel with: unique subject id (id), discrete time index (k), treatment (Ak), recurrent count (Yk), terminal event indicator (Tk), and optional covariates (here L.1, L.2).

History lagYk (default 0 at each subject’s first interval) captures short-term dependence. In our design, lagged history terms are fully flexible: users may supply their own lag variables (e.g., lagYk, higher-order lags, or custom functions of past outcomes) directly in the dataset and reference them in the formulas, or omit them entirely. If no lag variable is provided but lag terms are specified in the formulas, the function automatically constructs the appropriate lag internally. This guarantees valid defaults while allowing investigators to encode any history structure they need.

Continuous covariates are standardized to improve sampler geometry and prior interpretability.

Remove observations with missing values for variables used in the model formulas; if imputation is required, perform it upstream and re-use the same transform for prediction.

K equals the number of unique time intervals and controls the length of each model’s piecewise baseline.

```{r}
load("data.Rdata")
df_fit <- df %>%
  # filter(id %in% 1:100) %>%           #for subset
  arrange(id, k) %>%
  mutate(k_fac = as.integer(factor(k, levels = sort(unique(k))))) %>%
  group_by(id) %>%
  mutate(
    lagYk = if ("lagYk" %in% names(.)) replace_na(lagYk, 0) else lag(Yk, default = 0)
  ) %>%
  ungroup() %>%
  drop_na(Tk, Yk, Ak, L.1, L.2) %>%
  mutate(
    L.1 = as.numeric(scale(L.1)),
    L.2 = as.numeric(scale(L.2))
  )
K <- length(unique(df_fit$k_fac))
```

## 3. Bayesian Model Fitting

We now fit the joint model for the recurrent events and terminal process using Stan.

We fit a joint Bayesian model for (i) the terminal process Tk and (ii) the recurrent evernts Yk, sharing the discrete time structure and history recoords. Each sub-model includes: the current treatment, lagged outcomes (e.g. I(lagYk\^2)), standardized covariates (L.1, L.2), and a piecewise-constant baseline (time_baseline_T[j] / time_baseline_Y[j]).

We expose variable names in diagnostics and summaries as follows:

-   beta_T:L.1, beta_T:L.2, beta_Y:L.1, beta_Y:L.2: covariate (L.1, L.2 here) effects in T/Y models.

-   theta_T_lag:I(lagYk\^2), theta_Y_lag:I(lagYk\^2): coefficients for lagged outcome features.

-   time_baseline_T[j], time_baseline_Y[j]: j-th time-interval baselines capturing secular time trends.

-   treatment_effect_T, treatment_effect_Y: treatment effects for terminal and recurrent processes.

```{r}
# Stan fit
fit <- fit_causal_recur(
  data      = df_fit,
  K         = K,
  id_col    = "id",
  time_col  = "k_fac",
  treat_col = "Ak",
  lag_col   = "lagYk",
  formula_T = Tk ~ Ak + I(lagYk^2) + L.1 + L.2,
  formula_Y = Yk ~ Ak + I(lagYk^2) + L.1 + L.2,
  cores     = cores,
  verbose   = TRUE
)
```

## 4. MCMC Diagnostics

Evaluate convergence and identify any problematic chains. We report R-hat (target ≈ 1.00), effective sample size (should be large), and show traceplots grouped by model block.

```{r}
# MCMC Diagnosis
rstan::check_hmc_diagnostics(fit$stan_fit)
diag <- mcmc_diagnosis(fit)
plot(diag)
```

## 5. G-Computation

We simulate potential outcomes under hypothetical treatment strategies to estimate causal contrasts.

We target a marginal causal estimand that contrasts the expected cumulative outcome trajectory under different treatment initiation strategies. Formally, let $$
\Delta(s, K+1) \;=\; 
\mathbb{E}\!\left\{ Y_{1:K+1}(s) \right\} \;-\; 
\mathbb{E}\!\left\{ Y_{1:K+1}(\text{ref}) \right\},
$$ where $s \in s_{\text{vec}}$ denotes a treatment-start interval strategy and “ref” denotes the reference strategy (e.g., no intervention). Here $Y_{1:K+1}(s)$ is the cumulative number of events through interval $K+1$ under strategy $s$.

Estimation proceeds via Bayesian g-computation. For each posterior draw of model parameters, we simulate forward the joint process of survival and recurrent events under the intervention sequence $A_{1:K}(s)$, average across subjects, and repeat for the reference strategy. The causal contrast $\Delta(s,K+1)$ is then obtained as the posterior distribution of their difference: $$
\Delta(s,K+1)^{(m)} \;=\; 
\frac{1}{n}\sum_{i=1}^n 
\Bigg\{
\frac{\sum_{k=1}^K Y^{(m)}_{ik}(s)}
     {K - \sum_{k=1}^K T^{(m)}_{ik}(s)}
-
\frac{\sum_{k=1}^K Y^{(m)}_{ik}(\text{ref})}
     {K - \sum_{k=1}^K T^{(m)}_{ik}(\text{ref})}
\Bigg\},
$$ where $Y^{(m)}_{ik}(s)$ and $T^{(m)}_{ik}(s)$ denote simulated event and death indicators for subject $i$ at interval $k$ under posterior draw $m$. The full posterior of $\Delta(s,K+1)$ is summarized by its mean and credible interval. Wide intervals centered near zero indicate weak evidence for a treatment effect, in which case one may consider larger samples, stronger priors, or alternative summaries such as median effects or exceedance probabilities.

This simulation-based g-computation ensures that both survival and recurrent event processes are attributed consistently to each strategy, thereby yielding a valid causal interpretation of treatment-timing contrasts.

```{r}
baseline_df <- fit$data_preprocessed %>%
  group_by(pat_id) %>%
  slice_min(order_by = k_idx, n = 1) %>%
  arrange(pat_id) %>%
  ungroup()

gcomp <- g_computation(
  fit_out = fit,
  s_vec   = s_vec,
  B       = B,
  cores   = cores
)

print(gcomp)
plot(gcomp, ref_line = 0)
plot(gcomp, interactive = TRUE, ref_line = 0)
```

## 6. Switching Probability Summary

The switching probability summary quantifies how often subjects switch treatment across follow-up intervals. For each interval k, we estimate the within-subject probability of switching.

The switching probability summary quantifies how often subjects change treatment across follow-up intervals.\
There are two possible scales:

-   Mass (default): the marginal probability that switching occurs at interval k, which shows how many subjects in the population switched at each time point.
-   Hazard: the conditional probability of switching at interval k given that the subject has not yet switched before k.

By default, the function uses scale="mass":

```{r}
# default (scale="mass")
sw  <- switching_probability_summary(fit$data_preprocessed)                  
plot(sw)
```

```{r}
sw  <- switching_probability_summary(fit$data_preprocessed, scale="hazard")
plot(sw)
```

## 7. Summary of Causal Estimates

This table summarizes posterior distributions of model parameters and g-computation estimates. Parameter tables report Mean, 2.5%, 97.5%, R-hat, n_eff, MCSE, and CI width. Effects close to 0 with tight intervals imply little evidence of impact. Baseline blocks (time_baseline\_\*) quantify secular time risk; do not interpret them as treatment effects.

```{r}
sum_tbl <- result_summary_table(
  fit_out   = fit,
  gcomp_out = gcomp,
  s_vec     = s_vec,
  format    = "kable"
)
print(sum_tbl)
```
