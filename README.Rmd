---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# BayCauRETM

<!-- badges: start -->
[![R-CMD-check](https://github.com/LnnnnYW/BayCauRETM/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/LnnnnYW/BayCauRETM/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

**BayCauRETM** (Bayesian Causal Recurrent-Event and Terminal-Event Modeling) provides a full Bayesian workflow for discrete-time causal inference with recurrent events jointly modeled with a terminal event. It handles canonical data preprocessing, Stan-based joint modelling, posterior *g*-computation for alternative treatment start times, rich diagnostics, and publication-ready summaries.


## Installation

You can install the development version of BayCauRETM from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("LnnnnYW/BayCauRETM")
```

## Example

```{r full-workflow, eval = FALSE}
library(BayCauRETM)

## 1. Simulate toy data: 4 subjects × 3 intervals
set.seed(123)
toy <- data.frame(
  pat_id = rep(1:4, each = 3),
  k_idx  = rep(1:3, 4),
  Y_obs  = rpois(12, 1),
  T_obs  = rbinom(12, 1, 0.3),
  A      = rbinom(12, 1, 0.4)
)

## 2. Pre-process: add lags (Y_prev, T_prev) and fill missing intervals
pre <- preprocess_data(toy, K = 3)

## 3. Fit Bayesian joint model (tiny MCMC just for illustration)
fit <- fit_causal_recur(
  data       = pre$processed_df,
  K          = 3,
  formula_T  = T_obs ~ Y_prev + A + k_idx,
  formula_Y  = Y_obs ~ Y_prev + A + k_idx,
  prior      = list(
                 eta_beta  = 0, sigma_beta  = 1, rho_beta   = 0.5,
                 eta_gamma = 0, sigma_gamma = 1, rho_gamma  = 0.5),
  num_chains = 1,
  iter       = 200,      # increase for real analysis
  verbose    = FALSE
)

## 4. MCMC convergence diagnostics
diag <- mcmc_diagnosis(fit)
print(diag)
# plot(diag)

## 5. Posterior g-computation: start at s = 1, 2, 3 vs never
gout <- g_computation(fit, s_vec = 1:3, B = 30)
print(gout)
# plot(gout, ref_line = 0)

## 6. Propensity-score diagnostics
psd <- propensity_score_diagnostics(
         data       = fit$data_preprocessed,
         treat_col  = "A",
         covariates = c("Y_prev", "k_idx"))
# plot(psd, type = "histogram")

## 7. Switching-hazard diagnostics
sw <- switching_probability_summary(fit$data_preprocessed)
# plot(sw)

## 8. Merge posterior and g-computation summaries
tbl <- result_summary_table(fit, gout, s_vec = 1:3, format = "kable")
print(tbl)

```

### Why keep this file as **README.Rmd**?

Because an R Markdown-based README lets us run real R code every time we
knit, so the examples and figures always reflect the **current** version
of *BayCauRETM*.

```{r fit-summary, echo = TRUE, eval = FALSE}
summary(fit)
```

You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this.

You can also embed plots, for example:

```{r delta-plot, echo = TRUE, eval = FALSE}
# posterior contrast delta(s, K+1) with 95 % credible ribbon
plot(gout, ref_line = 0)
```

Knit with **Build ▸ Build README** or `devtools::build_readme()` whenever you change the code, and commit the PNG files under `man/figures/`.
